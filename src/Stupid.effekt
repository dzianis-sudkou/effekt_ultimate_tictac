module src/Stupid

import tty
import io/console
import stream
import src/lib

type Row = List[String]
type SmallBoard = List[List[String]]
type BigBoard = List[List[SmallBoard]]

type Player = String

def clearScreen(): Unit = {
  println("\u001b[2J") // clear the screen
  println("\u001b[H") // move the cursor to the top left corner
}

def renderBoard(board: BigBoard): Unit = {
  renderSeparator()
  board.foreach {elem =>  // elem is a List[SmallBoard]
    val bigRow: List[String] = createUnifiedRow(elem)
    renderRow(bigRow)
    renderSeparator()
    ()
  }
  ()
}

def createUnifiedRow(boardRow: List[SmallBoard]): List[String] = {
  with on[OutOfBounds].panic // disable all the error messages
  var unifiedRow: List[List[String]] = []
  var counterSmallBoard: Int = 0
  var counterRow: Int = 0
  while (counterRow < 3) {
    val smallBoard: SmallBoard = boardRow.get(counterSmallBoard)
    unifiedRow = unifiedRow.insert(unifiedRow.size(), smallBoard.get(counterRow)) // insert the row of the small board
    if (counterSmallBoard == 2) {
      unifiedRow = unifiedRow.insert(unifiedRow.size(), ["\n"]) // new line symbol
      counterSmallBoard = 0
      counterRow = counterRow + 1
    } else {
      unifiedRow = unifiedRow.insert(unifiedRow.size(), ["|"]) // insert the separator
      counterSmallBoard = counterSmallBoard + 1
    }
    ()
  }
  var resultRow: List[String] = unifiedRow.join()
  resultRow = resultRow.deleteAt(resultRow.size() - 1) // remove the last new line symbol
  resultRow
}

def renderRow(l: Row): Unit = {
  val rowString: String = l.foldLeft("") { (acc, elem) =>
    if (acc == "") {
      elem ++ " "
    }else { 
      if (elem == "\n") {
        acc ++ elem
      }else {
        acc ++ elem ++ " " 
      }
    }
  }
  println(rowString)
}

def renderSeparator(): Unit = {
  var separator: List[String] = fill(11, "—")
  separator = separator.replace(3, "+")
  separator = separator.replace(7, "+")
  renderRow(separator)
  ()
}

def generateNewBigBoard(): BigBoard = {
  val row1: Row = fill(3, "⚬")
  val smallBoard: SmallBoard = fill(3, row1)
  val bigBoard: BigBoard = fill(3,fill(3, smallBoard))
  bigBoard
}

def playGame(): Unit = {
  with console

  def chooseSide(): Player / {WrongInput} = {
    println("Choose the side[X, O]:")
    val side = do readLine()
    side match {
      case "X" => "X"
      case "O" => "O"
      case _ =>
        do WrongInput("Invalid player type. Please type 'X' or 'O'!")
        chooseSide()
    }
  }

  def chooseSmallBoard(): Int / {WrongInput} = {
    println("Choose the Small Board[1 - 9]:")
    val sBNumber: String = do readLine()
    if (not(any(Numbers) {elem => elem == sBNumber})) {
      do WrongInput("Invalid input. Please type a number from 1 to 9.")
      chooseSmallBoard()
    }else {
      with on[WrongFormat].panic
      val num: Int = toInt(sBNumber)
      num
    }
  }

  def gameLoop(): Unit / {WrongInput} = {
    var endGame: Bool = false
    var currentGameBoard: BigBoard = generateNewBigBoard()
    clearScreen()
    renderBoard(currentGameBoard)
    while (not(endGame)){
      var sB: Int = chooseSmallBoard()
      println("Your Small Board is " ++ sB.show)
      ()
    }
  }

  // MAIN SECTION

  clearScreen()

  println("Welcome to the ULTIMATE TIC-TAC-TOE!")
  println("Press enter to start the game.")
  do readLine()
  var play: Bool = true
  
  var currentGameBoard: BigBoard = generateNewBigBoard()

  var player: Player = ""
  while (play) {


    try{

      // Choosing a player side
      player = chooseSide()
      
      // Starting the game
      gameLoop()



    } with WrongInput { msg =>
      println(msg)
      println("\n")
      resume(())
    }
    ()
  }
  

  println("Goodbye: " ++ player)
}
def main(): Unit = {
  playGame()
}
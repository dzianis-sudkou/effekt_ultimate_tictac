module src/Opponent

import src/lib
import src/Generate


/*
 * Checks if it's a computer turn right now
 * Input : currentPlayer: Cell, computer: Cell
 * Output : Bool
 */
def isComputerTurn(currentPlayer: Cell, computer: Cell): Bool =
  (currentPlayer, computer) match {
    case (Cross(), Cross()) => true
    case (Nought(), Nought()) => true
    case _ => false
  }


/*
 * Computer Play Logic
 * Strategy
 * 1. Find winning move
 * 2. Block opponent's winning move
 * 3. Take center [4]
 * 4. Take corner [0,2,6,8]
 * 5. Take side [1,3,5,7]
 *
 * Input : smallBoard: SmallBoard, computer: Cell
 * Output : Int
 */
def computerPlay(smallBoard: SmallBoard, computer: Cell): Int = {
  val opponent: Cell = if (computer is Cross()) Nought() else Cross()
  
  smallBoard.findWinningMove(computer)
            .orElse{ smallBoard.findWinningMove(opponent) }
            .orElse{ [4,0,2,6,8].findFirstAvailable(smallBoard) }
            .orElse{ [1,3,5,7].findFirstAvailable(smallBoard) }
            .getOrElse {42}
}


/**
 * Finds first available move in a board using a given positions list
 * Input : positions: List[Int], board: SmallBoard
 * Output : Option[Int]
 */
def findFirstAvailable(positions: List[Int], board: SmallBoard): Option[Int] = {
  positions.find { pos => checkAvailableCell(board, pos) }
}


/**
 * Finds winning move in a board if exists
 * Input : board: SmallBoard, player: Cell
 * Output : Option[Int]
 */
def findWinningMove(board: SmallBoard, player: Cell): Option[Int] = {
  build(9){ i => i }.find { pos =>
    if (checkAvailableCell(board, pos)){
      val simulateBoard = board.replace(pos, player)
      val sit: Finish = checkWinSituation(simulateBoard, player)
      sit.state match {
        case Win() => true
        case _ => false
      }
    }else false
  }
}

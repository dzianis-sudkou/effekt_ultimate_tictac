module src/Generate

import tty
import io/console
import stream
import src/lib

/**
 * Generates a new BigBoard
 * Input : None
 * Output : BigBoards
 */
def generateNewBigBoard(): BigBoards = {
  val smallBoard: SmallBoard = fill(9, Empty())
  val bigBoard: BigBoard = fill(9, smallBoard)
  BigBoards(bigBoard, smallBoard)
}

def newActiveSmallBoard(bigBoards: BigBoards, number: Int): BigBoards = {
  with on[OutOfBounds].panic

  var newBigBoard: BigBoard = bigBoards.bigBoard
  var newBigBoardSmallCopy: SmallBoard = bigBoards.smallCopy
  var newSmallBoard: SmallBoard = newBigBoard.get(number - 1)


  // Making Active Cell in the Small Copy of the Big Board
  newBigBoardSmallCopy = newBigBoardSmallCopy.replace(number - 1, Active())
  
  // Replacing all the Empty() cells with Active()
  var counter: Int = 0
  newSmallBoard.foreach {cell =>
    cell match {
      case Empty() => newSmallBoard = newSmallBoard.replace(counter, Active())
      case _ => ()
    }
    counter = counter + 1
    ()
  }

  newBigBoard = newBigBoard.replace(number - 1, newSmallBoard)
  BigBoards(newBigBoard, newBigBoardSmallCopy)
}

def deactivateSmallBoard(bigBoards: BigBoards, number: Int): BigBoards = {
  with on[OutOfBounds].panic

  var newBigBoard: BigBoard = bigBoards.bigBoard
  var newBigBoardSmallCopy: SmallBoard = bigBoards.smallCopy
  
  var newSmallBoard: SmallBoard = newBigBoard.get(number - 1)
  var counter: Int = 0


  newSmallBoard.foreach {cell =>
    cell match {
      case Active() => newSmallBoard = newSmallBoard.replace(counter, Empty())
      case _ => ()
    }
    counter = counter + 1
    ()
  }
  newBigBoard = newBigBoard.replace(number - 1, newSmallBoard)
  BigBoards(newBigBoard, newBigBoardSmallCopy)
}

def checkNewCell(bigBoards: BigBoards, smallBoardNumber: Int, cellNumber: Int, player: Cell): BigBoards = {
  with on[OutOfBounds].panic

  var newBigBoard: BigBoard = bigBoards.bigBoard
  var newSmallBoard: SmallBoard = newBigBoard.get(smallBoardNumber - 1)
  newSmallBoard = newSmallBoard.replace(cellNumber - 1, player)
  newBigBoard = newBigBoard.replace(smallBoardNumber - 1, newSmallBoard)
  BigBoards(newBigBoard, bigBoards.smallCopy)
}

/*
 * Returns true if the Small Board is  free.
 * False Otherwise
 * Input : BigBoards, SmallBoardNumber, Cell Number
 * Output : Boolean
 */
def checkAvailableSmallBoard(bigBoards: BigBoards, cellNumber: Int): Bool = {
  with console
  with on[OutOfBounds].panic

  val cellType: Cell = bigBoards.smallCopy.get(cellNumber - 1)

  cellType match {
    case Empty() => true
    case Active() => true
    case _ => false
  }
}


/*
 * Returns true if the cell is  free.
 * False Otherwise
 * Input : BigBoards, SmallBoardNumber, Cell Number
 * Output : Boolean
 */
def checkAvailableCell(bigBoards: BigBoards, smallBoardNumber: Int, cellNumber: Int): Bool = {
  with on[OutOfBounds].panic

  var newBigBoard: BigBoard = bigBoards.bigBoard
  var newSmallBoard: SmallBoard = newBigBoard.get(smallBoardNumber - 1)
  val cellType: Cell = newSmallBoard.get(cellNumber - 1)
  if (cellType is Active()) true
  else false
}

/*
 * Returns true if Current Player has won in this Small Board.
 * False Otherwise
 * Input : SmallBoardNumber, player
 * Output : Boolean
 */
def checkWinSituation(smallBoard: SmallBoard, player: Cell): WinBoard = {
  var cr: Bool = true
  if (player is Cross()) cr = true else cr = false
  var checkedCells: List[Int] = empty()
  var counter: Int = 0
  var win: WinBoard = Nope()
  
  smallBoard.foreach {cell =>
    cell match {
      case Cross() => if (cr) checkedCells = checkedCells.insert(checkedCells.size(), counter)
      case Nought() => if (not(cr)) checkedCells = checkedCells.insert(checkedCells.size(), counter)
      case _ => ()
    }
    counter = counter + 1
  }
  counter = 0
  // Here we are checking if all three elements from the win combination are in the
  // Checked cells list
  winCombinations.foreach { combination =>
    combination.foreach { el =>
      if(any(checkedCells) {cell => cell == el}) counter = counter + 1
    }
    if (counter == 3) win = Win()
    else counter = 0
  }

  // Check if there's a draw in board
  counter = 0
  if (win is Nope()){
      smallBoard.foreach {cell =>
      cell match {
        case Cross() => counter = counter + 1
        case Nought() => counter = counter + 1
        case _ => ()
      }
      if (counter == 9) {
        win = Loose()
      }
    }
  }
  win
}

def fillWinningGameBoard(bigBoards: BigBoards, smallBoardNumber: Int, player: Cell): BigBoards = {
  var newBigBoard: BigBoard = bigBoards.bigBoard
  var newBigBoardSmallCopy: SmallBoard = bigBoards.smallCopy

  newBigBoard = newBigBoard.replace(smallBoardNumber - 1, fill(9, player))
  newBigBoardSmallCopy = newBigBoardSmallCopy.replace(smallBoardNumber - 1, player)
  BigBoards(newBigBoard, newBigBoardSmallCopy)
}
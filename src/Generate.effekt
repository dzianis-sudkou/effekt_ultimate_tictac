module src/Generate

import tty
import io/console
import stream
import src/lib

/**
 * Generates a new BigBoard
 * Input : None
 * Output : BigBoards
 */
def generateNewBigBoard(): BigBoards = {
  val smallBoard: SmallBoard = fill(9, Empty())
  val bigBoard: BigBoard = fill(9, smallBoard)
  BigBoards(bigBoard, smallBoard)
}

def newActiveSmallBoard(bigBoards: BigBoards, number: Int): BigBoards = {
  with on[OutOfBounds].panic

  var newBigBoard: BigBoard = bigBoards.bigBoard
  var newBigBoardSmallCopy: SmallBoard = bigBoards.smallCopy
  var newSmallBoard: SmallBoard = newBigBoard.get(number - 1)


  // Making Active Cell in the Small Copy of the Big Board
  newBigBoardSmallCopy = newBigBoardSmallCopy.replace(number - 1, Active())
  
  // Replacing all the Empty() cells with Active()
  var counter: Int = 0
  newSmallBoard.foreach {cell =>
    cell match {
      case Empty() => newSmallBoard = newSmallBoard.replace(counter, Active())
      case _ => ()
    }
    counter = counter + 1
    ()
  }

  newBigBoard = newBigBoard.replace(number - 1, newSmallBoard)
  BigBoards(newBigBoard, newBigBoardSmallCopy)
}

def deactivateSmallBoard(bigBoards: BigBoards, number: Int): BigBoards = {
  with on[OutOfBounds].panic

  var newBigBoard: BigBoard = bigBoards.bigBoard
  var newBigBoardSmallCopy: SmallBoard = bigBoards.smallCopy
  
  var newSmallBoard: SmallBoard = newBigBoard.get(number - 1)
  if(newSmallBoard.get(number - 1) is Filled(Player)){
    ()
  }else {
    newBigBoardSmallCopy = newBigBoardSmallCopy.replace(number - 1, Empty())
  }
  var counter: Int = 0


  newSmallBoard.foreach {cell =>
    cell match {
      case Active() => newSmallBoard = newSmallBoard.replace(counter, Empty())
      case _ => ()
    }
    counter = counter + 1
    ()
  }
  newBigBoard = newBigBoard.replace(number - 1, newSmallBoard)
  BigBoards(newBigBoard, newBigBoardSmallCopy)
}

def checkNewCell(bigBoards: BigBoards, smallBoardNumber: Int, cellNumber: Int, player: Player): BigBoards = {
  with on[OutOfBounds].panic

  var newBigBoard: BigBoard = bigBoards.bigBoard
  var newSmallBoard: SmallBoard = newBigBoard.get(smallBoardNumber - 1)
  newSmallBoard = newSmallBoard.replace(cellNumber - 1, Filled(player))
  newBigBoard = newBigBoard.replace(smallBoardNumber - 1, newSmallBoard)
  BigBoards(newBigBoard, bigBoards.smallCopy)
}

/*
 * Returns true if the Small Board is  free.
 * False Otherwise
 * Input : BigBoards, SmallBoardNumber, Cell Number
 * Output : Boolean
 */
def checkAvailableSmallBoard(bigBoards: BigBoards, cellNumber: Int): Bool = {
  with console
  with on[OutOfBounds].panic

  val cellType: Cell = bigBoards.smallCopy.get(cellNumber - 1)

  cellType match {
    case Empty() => true
    case Active() => true
    case Filled(Player) => false
    case _ => false
  }
}


/*
 * Returns true if the cell is  free.
 * False Otherwise
 * Input : BigBoards, SmallBoardNumber, Cell Number
 * Output : Boolean
 */
def checkAvailableCell(bigBoards: BigBoards, smallBoardNumber: Int, cellNumber: Int): Bool = {
  with on[OutOfBounds].panic

  var newBigBoard: BigBoard = bigBoards.bigBoard
  var newSmallBoard: SmallBoard = newBigBoard.get(smallBoardNumber - 1)
  val cellType: Cell = newSmallBoard.get(cellNumber - 1)
  if (cellType is Active()) true
  else false
}

/*
 * Returns true if Current Player has won in this Small Board.
 * False Otherwise
 * Input : SmallBoardNumber, player
 * Output : Boolean
 */
def checkWinSituation(smallBoard: SmallBoard, player: Player): Bool = {
  var checkedCells: List[Int] = empty()
  var counter: Int = 0
  var win: Bool = false
  smallBoard.foreach {cell =>
    cell match {
      case Filled(player) => checkedCells = checkedCells.insert(checkedCells.size(), counter)
      case _ => ()
    }
    counter = counter + 1
  }
  counter = 0
  // Here we are checking if all three elements from the win combination are in the 
  // Checked cells list
  winCombinations.foreach { combination =>
    combination.foreach { el =>
      if(any(checkedCells) {cell => cell == el}) counter = counter + 1
    }
    if (counter == 3) win = true
    else counter = 0
  }
  win
}

def fillWinningGameBoard(bigBoards: BigBoards, smallBoardNumber: Int, player: Player): BigBoards = {
  var newBigBoard: BigBoard = bigBoards.bigBoard
  var newBigBoardSmallCopy: SmallBoard = bigBoards.smallCopy

  newBigBoard = newBigBoard.replace(smallBoardNumber - 1, fill(9, Filled(player)))
  newBigBoardSmallCopy = newBigBoardSmallCopy.replace(smallBoardNumber - 1, Filled(player))
  BigBoards(newBigBoard, newBigBoardSmallCopy)
}
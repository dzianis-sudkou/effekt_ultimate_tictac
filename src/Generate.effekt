module src/Generate

import tty
import io/console
import stream
import src/lib

/**
 * Generates a new BigBoard
 * Input : None
 * Output : BigBoards
 */
def generateNewBigBoard(): BigBoards = {
  val smallBoard: SmallBoard = fill(9, Empty())
  val bigBoard: BigBoard = fill(9, smallBoard)
  BigBoards(bigBoard, smallBoard)
}

def newActiveSmallBoard(bigBoards: BigBoards, number: Int): BigBoards = {
  with on[OutOfBounds].panic

  var newBigBoard: BigBoard = bigBoards.bigBoard
  var newBigBoardSmallCopy: SmallBoard = bigBoards.smallCopy
  var newSmallBoard: SmallBoard = newBigBoard.get(number - 1)


  // Making Active Cell in the Small Copy of the Big Board
  newBigBoardSmallCopy = newBigBoardSmallCopy.replace(number - 1, Active())
  
  // Replacing all the Empty() cells with Active()
  var counter: Int = 0
  newSmallBoard.foreach {cell =>
    cell match {
      case Empty() => newSmallBoard = newSmallBoard.replace(counter, Active())
      case _ => ()
    }
    counter = counter + 1
    ()
  }

  newBigBoard = newBigBoard.replace(number - 1, newSmallBoard)
  BigBoards(newBigBoard, newBigBoardSmallCopy)
}

def deactivateSmallBoard(bigBoards: BigBoards, number: Int): BigBoards = {
  with on[OutOfBounds].panic

  var newBigBoard: BigBoard = bigBoards.bigBoard
  var newSmallBoard: SmallBoard = newBigBoard.get(number - 1)
  var counter: Int = 0


  newSmallBoard.foreach {cell =>
    cell match {
      case Active() => newSmallBoard = newSmallBoard.replace(counter, Empty())
      case _ => ()
    }
    counter = counter + 1
    ()
  }
  newBigBoard = newBigBoard.replace(number - 1, newSmallBoard)
  BigBoards(newBigBoard, bigBoards.smallCopy)
}

def checkNewCell(bigBoards: BigBoards, smallBoardNumber: Int, cellNumber: Int, player: Player): BigBoards = {
  with on[OutOfBounds].panic

  var newBigBoard: BigBoard = bigBoards.bigBoard
  var newSmallBoard: SmallBoard = newBigBoard.get(smallBoardNumber - 1)
  newSmallBoard = newSmallBoard.replace(cellNumber - 1, Filled(player))
  newBigBoard = newBigBoard.replace(smallBoardNumber - 1, newSmallBoard)
  BigBoards(newBigBoard, bigBoards.smallCopy)
}

/*
 * Returns true if the Small Board is  free.
 * False Otherwise
 * Input : BigBoards, SmallBoardNumber, Cell Number
 * Output : Boolean
 */
def checkAvailableSmallBoard(bigBoards: BigBoards, cellNumber: Int): Bool = {
  with on[OutOfBounds].panic

  val cellType: Cell = bigBoards.smallCopy.get(cellNumber - 1)
  if (cellType is Empty()) true
  else false
}


/*
 * Returns true if the cell is  free.
 * False Otherwise
 * Input : BigBoards, SmallBoardNumber, Cell Number
 * Output : Boolean
 */
def checkAvailableCell(bigBoards: BigBoards, smallBoardNumber: Int, cellNumber: Int): Bool = {
  with on[OutOfBounds].panic

  var newBigBoard: BigBoard = bigBoards.bigBoard
  var newSmallBoard: SmallBoard = newBigBoard.get(smallBoardNumber - 1)
  val cellType: Cell = newSmallBoard.get(cellNumber - 1)
  if (cellType is Active()) true
  else false
}

/*
 * Returns true if Current Player has won in this Small Board.
 * False Otherwise
 * Input : BigBoards, SmallBoardNumber, Cell Number
 * Output : Boolean
 */
def checkWinSituation(smallBoard: SmallBoard, player: Player): Bool = {
  var checkedCells: List[Int] = empty()
  var counter: Int = 0
  var win: Bool = true
  smallBoard.foreach {cell =>
    cell match {
      case Filled(player) => checkedCells = checkedCells.insert(checkedCells.size(), counter)
      case _ => ()
    }
    counter = counter + 1
  }
  winCombinations.foreach { combination =>
    if(combination.compare(checkedCells)){
      win = true
    }
  }
  win
}